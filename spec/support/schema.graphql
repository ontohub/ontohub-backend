# Describes a evaluation state and contains a possible message
type Action {
  # The state of evaluation
  evaluationState: EvaluationState!

  # A message describing details of the state
  message: String
}

# An axiom
type Axiom implements LocIdBase & Sentence {
  # The FileRange of this Sentence's definition
  fileRange: FileRange

  # The FileVersion to which this object belongs
  fileVersion: FileVersion!

  # The Loc/Id of the document
  locId: ID!

  # The name of the Sentence
  name: String!

  # The OMS to which this Sentence belongs
  oms: OMS!

  # The symbols used in this sentence
  symbols(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [Symbol!]!

  # The definitional text of this Sentence
  text: String!
}

# Basic data of a repository
interface BaseRepository {
  # Type of the repository
  contentType: RepositoryContentType!

  # Description of the repository
  description: String

  # ID of the repository
  id: ID!

  # List of the repository's memberships
  memberships(
    # Maximum number of memberships to list
    limit: Int = 20

    # Filter the users by the membership role
    role: RepositoryRole

    # Skip the first n memberships
    skip: Int = 0
  ): [RepositoryMembership!]!

  # Name of the repository
  name: String!

  # Owner of the repository
  owner: OrganizationalUnit!

  # The current_user's permissions for this repository
  permissions: RepositoryPermissions

  # List of all URL Mappings of this repository
  urlMappings: [UrlMapping!]!

  # Visibility of the repository
  visibility: RepositoryVisibility!
}

# A git branch
type Branch implements Reference {
  # The name of the reference
  name: String!

  # The referenced commit
  target: Commit!
}

# A commit of a repository
type Commit {
  # The author of the commit
  author: GitUser!

  # The time the commit was authored at
  authoredAt: Time!

  # The time the commit was created
  committedAt: Time!

  # The committer of the commit
  committer: GitUser!

  # The changes that this commit introduced
  diff: [Diff!]!

  # The entries of a directory
  directory(
    # The path to the directory to list
    path: ID!
  ): [Directory!]

  # A document containing OMS data
  document(
    # The Loc/Id of the document
    locId: ID!
  ): Document

  # A file
  file(
    # Load more than the 10 Megabytes for the web view
    loadAllData: Boolean = false

    # The path to the file
    path: ID!
  ): File

  # A FileVersion for the given path
  fileVersion(
    # The path of the FileVersion
    path: ID!
  ): FileVersion

  # The sha hash of the commit
  id: ID!

  # A list of all file paths in the repository
  lsFiles: [String!]!

  # A Mapping
  mapping(
    # The Loc/Id of the Mapping
    locId: ID!
  ): Mapping

  # The commit message
  message: String!

  # An OMS
  oms(
    # The Loc/Id of the OMS
    locId: ID!
  ): OMS

  # The parents of the commit
  parentIds: [ID!]!

  # The names of the references that point to this commit
  referenceNames: [String!]!

  # The references that point to this commit
  references: [Reference!]!

  # A Sentence
  sentence(
    # The Loc/Id of the Sentence
    locId: ID!
  ): Sentence

  # A Symbol
  symbol(
    # The Loc/Id of the Symbol
    locId: ID!
  ): Symbol
}

# Possible actions for a commit
enum CommitAction {
  create
  mkdir
  remove
  rename
  rename_and_update
  update
}

# A conjecture
interface Conjecture {
  # Information about the (to be) performed action
  action: Action!

  # The FileRange of this Sentence's definition
  fileRange: FileRange

  # The FileVersion to which this object belongs
  fileVersion: FileVersion!

  # The Loc/Id of the document
  locId: ID!

  # The name of the Sentence
  name: String!

  # The OMS to which this Sentence belongs
  oms: OMS!

  # The attempts to prove this Conjecture
  proofAttempts(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [ProofAttempt!]!

  # The proof status of this Conjecture
  proofStatus: ProofStatus!

  # The symbols used in this sentence
  symbols(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [Symbol!]!

  # The definitional text of this Sentence
  text: String!
}

# A conservativity status
type ConservativityStatus {
  # The proved conservativity value
  proved: String!

  # The required conservativity value
  required: String!
}

# An attempt to check consistency of an OMS
type ConsistencyCheckAttempt implements ReasoningAttempt {
  # Information about the (to be) performed action
  action: Action!

  # The consistency status of this ConsistencyCheckAttempt
  consistencyStatus: ConsistencyStatus!

  # Axioms that have been generated during reasoning
  generatedAxioms: [GeneratedAxiom!]!

  # The ID of this ReasoningAttempt
  id: Int!

  # The number of this ReasoningAttempt
  number: Int!

  # The OMS of interest
  oms: OMS!

  # The used ReasonerConfiguration
  reasonerConfiguration: ReasonerConfiguration!

  # The output of the Reasoner
  reasonerOutput: ReasonerOutput

  # The time it took to run the reasoner
  timeTaken: Int

  # The used Reasoner
  usedReasoner: Reasoner!
}

# Specifies the consistency status of an OMS
enum ConsistencyStatus {
  # The OMS is consistent.
  Consistent

  # There are concistency attempts that found a proof as well as some that found a
  # counter example. This indicates a malfunction of the reasoning system.
  Contradictory

  # A concistency attempt has failed.
  Error

  # The OMS is inconsistent.
  Inconsistent

  # No concistency attempt has been finished.
  Open

  # The reasoner ran out of time.
  Timeout
}

# A counter-theorem (disproved conjecture)
type CounterTheorem implements Conjecture & LocIdBase & Sentence {
  # Information about the (to be) performed action
  action: Action!

  # The FileRange of this Sentence's definition
  fileRange: FileRange

  # The FileVersion to which this object belongs
  fileVersion: FileVersion!

  # The Loc/Id of the document
  locId: ID!

  # The name of the Sentence
  name: String!

  # The OMS to which this Sentence belongs
  oms: OMS!

  # The attempts to prove this Conjecture
  proofAttempts(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [ProofAttempt!]!

  # The proof status of this Conjecture
  proofStatus: ProofStatus!

  # The symbols used in this sentence
  symbols(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [Symbol!]!

  # The definitional text of this Sentence
  text: String!
}

# A debug message
type Debug implements Diagnosis {
  # The FileRange that this message is about
  fileRange: FileRange

  # The FileVersion which this message is about
  fileVersion: FileVersion!

  # The number of this message
  number: Int!

  # The actual message
  text: String!
}

# A message about a file's content
interface Diagnosis {
  # The FileRange that this message is about
  fileRange: FileRange

  # The FileVersion which this message is about
  fileVersion: FileVersion!

  # The number of this message
  number: Int!

  # The actual message
  text: String!
}

# Change of a file
type Diff {
  # True if the file was deleted
  deletedFile: Boolean!

  # The actual diff
  diff: String!

  # The number of changed lines
  lineCount: Int!

  # True if the file was added
  newFile: Boolean!

  # The file mode in the new state
  newMode: String!

  # The new path of the file
  newPath: String!

  # The file mode in the old state
  oldMode: String!

  # The old path of the file
  oldPath: String!

  # True if the file was renamed
  renamedFile: Boolean!
}

# A directory of a repository
type Directory implements DirectoryEntry {
  # The history (git log) of this entry starting with the most recent changes
  log(
    # Only show commits from after this date/time
    after: Time

    # Only show commits from before this date/time
    before: Time

    # Maximum number of commits to list
    limit: Int = 20

    # Skip the first n commits
    skip: Int = 0

    # Whether or not to skip merge commits in the history
    skipMerges: Boolean = false
  ): [Commit!]!

  # The name of the entry
  name: String!

  # The path of the entry
  path: String!
}

# A directory entry (directory or file) of a repository
interface DirectoryEntry {
  # The history (git log) of this entry starting with the most recent changes
  log(
    # Only show commits from after this date/time
    after: Time

    # Only show commits from before this date/time
    before: Time

    # Maximum number of commits to list
    limit: Int = 20

    # Skip the first n commits
    skip: Int = 0

    # Whether or not to skip merge commits in the history
    skipMerges: Boolean = false
  ): [Commit!]!

  # The name of the entry
  name: String!

  # The path of the entry
  path: String!
}

# A Document is a container for OMS
interface Document {
  # All DocumentLinks that this Document is part of
  documentLinks(
    # Maximum number of entries to list
    limit: Int = 20

    # Specifies which end of the link the current document is. Possible values: 'source', 'target'
    origin: LinkOrigin = any

    # Skip the first n entries
    skip: Int = 0
  ): [DocumentLink!]!

  # The FileVersion to which this object belongs
  fileVersion: FileVersion!

  # The documents which import this Document
  importedBy(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [Document!]!

  # The documents which are imported by this Document
  imports(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [Document!]!

  # The Loc/Id of the document
  locId: ID!
}

# A DocumentLink shows a dependency between Documents
type DocumentLink {
  # The source Document
  source: Document!

  # The target Document
  target: Document!
}

# An error message
type Error implements Diagnosis {
  # The FileRange that this message is about
  fileRange: FileRange

  # The FileVersion which this message is about
  fileVersion: FileVersion!

  # The number of this message
  number: Int!

  # The actual message
  text: String!
}

# Specifies the state of evaluation
enum EvaluationState {
  # The object has been enqueued but is not yet processing
  enqueued

  # The object has been evaluated successfully
  finished_successfully

  # The evaluation of this object has failed
  finished_unsuccessfully

  # The object has not yet been enqueued for evaluation
  not_yet_enqueued

  # The object is currently in evaluation
  processing
}

# A file of a repository
type File implements DirectoryEntry {
  # The content of the file
  content: String!

  # The encoding of the content
  encoding: FileEncoding!

  # The number of bytes that has been loaded of the content
  loadedSize: Int!

  # The history (git log) of this entry starting with the most recent changes
  log(
    # Only show commits from after this date/time
    after: Time

    # Only show commits from before this date/time
    before: Time

    # Maximum number of commits to list
    limit: Int = 20

    # Skip the first n commits
    skip: Int = 0

    # Whether or not to skip merge commits in the history
    skipMerges: Boolean = false
  ): [Commit!]!

  # The name of the entry
  name: String!

  # The path of the entry
  path: String!

  # The size in bytes
  size: Int!
}

# A file from a repository
input FileChangeset {
  # The action to be performed on the file
  action: CommitAction!

  # The new content of the file
  content: String

  # The encoding of the content
  encoding: FileEncoding

  # The new path of the file for renaming/moving
  new_path: String

  # The path of the file inside the repository
  path: String!
}

# Possible values for file encodings
enum FileEncoding {
  base64
  plain
}

# Positional information of a text element in a file
type FileRange {
  # The column of the text element's end
  endColumn: Int!

  # The line of the text element's end
  endLine: Int!

  # The file path
  path: String!

  # The column of the text element's beginning
  startColumn: Int!

  # The line of the text element's beginning
  startLine: Int!
}

# A versioned file
type FileVersion {
  # Information about the (to be) performed action
  action: Action!

  # The Commit that introduced this FileVersion
  commit: Commit!

  # The path of this file
  path: String!

  # The repository to which this FileVersion belongs
  repository: Repository!
}

# An that has been generated during reasoning
type GeneratedAxiom {
  # The ID of the GeneratedAxiom
  id: Int!

  # The ReasoningAttempt in which this axiom has been generated
  reasoningAttempt: ReasoningAttempt!

  # The definitional text
  text: String!
}

# An action in git
enum GitAction {
  # Pull from a repository
  pull

  # Push to a repository
  push
}

# Data of a git user
type GitUser {
  # Corresponding Ontohub account of the user
  account: User

  # Email address of the user
  email: String!

  # Name of the user
  name: String!
}

# Category to search in
enum GlobalSearchCategory {
  # Search only for organizational units
  organizationalUnits

  # Search only for repositories
  repositories
}

# The total numbers of results
type GlobalSearchCount {
  # The total number of search results
  all: Int!

  # The total number of found organizational units
  organizationalUnits: Int!

  # The total number of found repositories
  repositories: Int!
}

# Possible search result types
union GlobalSearchEntry = Organization | Repository | User

# Search results within the global scope
type GlobalSearchScope {
  # The total numbers of found entries
  count: GlobalSearchCount!

  # A list of result entries
  entries: [RankedGlobalSearchEntry!]!
}

# A hint
type Hint implements Diagnosis {
  # The FileRange that this message is about
  fileRange: FileRange

  # The FileVersion which this message is about
  fileVersion: FileVersion!

  # The number of this message
  number: Int!

  # The actual message
  text: String!
}

# A logical language
type Language {
  # Where this language has been defined
  definedBy: String!

  # The description of this language
  description: String!

  # The ID of this language
  id: ID!

  # A LanguageMapping of which this Language is the source or the target
  languageMappings(
    # Maximum number of entries to list
    limit: Int = 20

    # Specifies which end of the link the current Language is
    origin: LinkOrigin = any

    # Skip the first n entries
    skip: Int = 0
  ): [LanguageMapping!]!

  # The logics of this Language
  logics(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [Logic!]!

  # The name of this language
  name: String!

  # The standardization status of this language
  standardizationStatus: String!
}

# A mapping between two languages
type LanguageMapping {
  # The ID of this LanguageMapping
  id: Int!

  # The source language
  source: Language!

  # The target language
  target: Language!
}

# A Library is a container for any number of OMS
type Library implements Document & LocIdBase {
  # All DocumentLinks that this Document is part of
  documentLinks(
    # Maximum number of entries to list
    limit: Int = 20

    # Specifies which end of the link the current document is. Possible values: 'source', 'target'
    origin: LinkOrigin = any

    # Skip the first n entries
    skip: Int = 0
  ): [DocumentLink!]!

  # The FileVersion to which this object belongs
  fileVersion: FileVersion!

  # The documents which import this Document
  importedBy(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [Document!]!

  # The documents which are imported by this Document
  imports(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [Document!]!

  # The Loc/Id of the document
  locId: ID!

  # A list of OMS in this Library
  oms(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [OMS!]!
}

# Specifies which end of the link the current object is
enum LinkOrigin {
  # The current object is any end of the link
  any

  # The current object is the source of the link
  source

  # The current object is the target of the link
  target
}

# An object with a Loc/Id
interface LocIdBase {
  # The FileVersion to which this object belongs
  fileVersion: FileVersion!

  # The Loc/Id of the document
  locId: ID!
}

# A logic
type Logic {
  # The ID of this logic
  id: ID!

  # The language to which this logic belongs
  language: Language!

  # A LogicMapping of which this Logic is the source or the target
  logicMappings(
    # Maximum number of entries to list
    limit: Int = 20

    # Specifies which end of the link the current Logic is
    origin: LinkOrigin = any

    # Skip the first n entries
    skip: Int = 0
  ): [LogicMapping!]!

  # The name of this logic
  name: String!
}

# A mapping between two logics
type LogicMapping {
  # The ID of this LogicMapping
  id: ID!

  # The LanguageMapping to which this LogicMapping belongs
  languageMapping: LanguageMapping!

  # The source logic
  source: Logic!

  # The target logic
  target: Logic!
}

# A PremiseSelection whose premises were selected by hand
type ManualPremiseSelection implements PremiseSelection {
  # The ID of the PremiseSelection
  id: Int!

  # The used ReasonerConfiguration
  reasonerConfiguration: ReasonerConfiguration!

  # The selected premises
  selectedPremises(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [Sentence!]!
}

# A mapping between two OMS
type Mapping implements LocIdBase {
  # The ConservativityStatus of this Mapping
  conservativityStatus: ConservativityStatus!

  # The human-friendly name of this Mapping
  displayName: String!

  # The FileVersion to which this object belongs
  fileVersion: FileVersion!

  # The Language of the Mapping's freeness parameter
  freenessParameterLanguage: Language

  # The OMS of the Mapping's freeness parameter
  freenessParameterOMS: OMS

  # The Loc/Id of the document
  locId: ID!

  # The technical name of this Mapping
  name: String!

  # The origin of this Mapping
  origin: MappingOrigin!

  # True if there are open proofs in this Mapping
  pending: Boolean!

  # The SignatureMorphism that this Mapping uses
  signatureMorphism: SignatureMorphism!

  # The source of the Mapping
  source: OMS!

  # The target of the Mapping
  target: OMS!

  # The type of this Mapping
  type: MappingType!
}

# Specifies the origin (in the DOL document) of the Mapping
enum MappingOrigin {
  # implied extension
  dg_implies_link

  # alignment
  dg_link_align

  # closure OMS
  dg_link_closed_lenv

  # extension OMS
  dg_link_extension

  # fitting view on an instantiation of a parameterised OMS (CASL syntax)
  dg_link_fit_view

  # implict fitting view on an instantiation of a parameterised OMS (CASL syntax)
  dg_link_fit_view_imp

  # flattening of an OMS translation
  dg_link_flattening_rename

  # flattening of an OMS union
  dg_link_flattening_union

  # CASL imports
  dg_link_imports

  # reference to an OMS
  dg_link_inst

  # argument of a parameterised OMS (CASL syntax)
  dg_link_inst_arg

  # intersection
  dg_link_intersect

  # morphism created during an instantiation of a parameterised OMS (CASL syntax)
  dg_link_morph

  # proof within the development graph calculus
  dg_link_proof

  # refinement of OMS
  dg_link_refinement

  # translation OMS
  dg_link_translation

  # development graph calculus
  dg_link_verif

  # interpretation (view)
  dg_link_view

  # that of the target OMS of the mapping
  see_source

  # that of the source OMS of the mapping
  see_target

  # used for testing purposes
  test
}

# Specifies the type of the Mapping (=link in the development graph)
enum MappingType {
  # cofree definition link
  cofree_def

  # open cofree theorem link
  cofree_open

  # proved cofree theorem link
  cofree_proved

  # free definition link
  free_def

  # open free theorem link
  free_open

  # proved free theorem link
  free_proved

  # global definition link
  global_def

  # open global theorem link
  global_thm_open

  # proved global theorem link
  global_thm_proved

  # hiding defintion link
  hiding_def

  # open hiding theorem link
  hiding_open

  # proved hiding theorem link
  hiding_proved

  # local definition link
  local_def

  # open local theorem link
  local_thm_open

  # proved local theorem link
  local_thm_proved

  # minimization definition link
  minimize_def

  # open minimization theorem link
  minimize_open

  # proved minimization theorem link
  minimize_proved

  # free definition link generated by Maude
  np_free_def

  # open free theorem link generated by Maude
  np_free_open

  # proved free theorem link generated by Maude
  np_free_proved
}

# Base mutation type
type Mutation {
  # Adds a new member to an organization or updates an existing membership
  addOrganizationMember(
    # The ID of the member
    member: ID!

    # The ID of the organization
    organization: ID!

    # The role in the organization
    role: OrganizationRole!
  ): OrganizationMembership

  # Adds a new SSH public key
  addPublicKey(
    # The public key to add
    key: String!
  ): PublicKey

  # Adds a new member to a repository or updates an existing membership
  addRepositoryMember(
    # The ID of the member
    member: ID!

    # The ID of the repository
    repository: ID!

    # The role in the repository
    role: RepositoryRole!
  ): RepositoryMembership

  # Adds a new URL Mapping
  addUrlMapping(
    # The ID of the repository
    repositoryId: ID!

    # The search substring of the URL
    source: String!

    # The replacement string of the URL
    target: String!
  ): UrlMapping

  # Clones a repository from a remote server
  cloneRepository(
    # The parameters of the new repository
    data: NewRepository!

    # The address of a remote repository
    remoteAddress: String!

    # The type of the cloned repository
    remoteType: RepositoryRemoteType!

    # The orignial Url Mapping that are applied to the repository
    urlMappings: [NewUrlMapping!]!
  ): RepositoryWithoutGit

  # Creates a new commit
  commit(
    # The information of the commit
    newCommit: NewCommit!

    # The repository to create the branch in
    repositoryId: ID!
  ): Commit

  # Confirms the email address of a user
  confirmEmail(
    # The confirmation token from the confirmation email
    token: String!
  ): SessionToken

  # Creates a new branch
  createBranch(
    # The name of the branch
    name: String!

    # The repository to create the branch in
    repositoryId: ID!

    # The revision the branch shall point to
    revision: ID!
  ): Branch

  # Creates a new organization
  createOrganization(
    # The parameters of the new organization
    data: NewOrganization!
  ): Organization

  # Creates a new repository
  createRepository(
    # The parameters of the new repository
    data: NewRepository!
  ): Repository

  # Creates a new tag
  createTag(
    # An optional annotation for the tag
    annotation: String

    # The name of the tag
    name: String!

    # The repository to create the tag in
    repositoryId: ID!

    # The revision the tag shall point to
    revision: ID!
  ): Tag

  # Deletes the account of the currently signed in user.
  # Returns `true` if it was successful and `null` if there was an error.
  deleteAccount(
    # Password of the current user to confirm the deletion
    password: String!
  ): Boolean

  # Creates a new branch
  deleteBranch(
    # The name of the branch
    name: String!

    # The repository to delete the branch from
    repositoryId: ID!
  ): Boolean

  # Deletes an organization.
  # Returns `true` if it was successful and `null` if there was an error.
  deleteOrganization(
    # The ID of the organization to delete
    id: ID!
  ): Boolean

  # Deletes a repository
  deleteRepository(
    # The ID of the repository to delete
    id: ID!
  ): Boolean

  # Creates a new tag
  deleteTag(
    # The name of the tag
    name: String!

    # The repository to delete the tag from
    repositoryId: ID!
  ): Boolean

  # Removes a member from an organization
  removeOrganizationMember(
    # The ID of the member
    member: ID!

    # The ID of the organization
    organization: ID!
  ): Boolean

  # Removes an SSH public key
  removePublicKey(
    # The name of the public key to remove
    name: String!
  ): Boolean

  # Removes a member from a repository
  removeRepositoryMember(
    # The ID of the member
    member: ID!

    # The ID of the repository
    repository: ID!
  ): Boolean

  # Removes an URL Mapping
  removeUrlMapping(
    # The ID of the repository in which the URL mapping exits
    repositoryId: ID!

    # The ID of the URL mapping
    urlMappingId: ID!
  ): Boolean

  # Resends the confirmation email to a user
  resendConfirmationEmail(
    # The email address of the user
    email: String!
  ): Boolean!

  # Resends the password reset email to a user
  resendPasswordResetEmail(
    # The email address of the user
    email: String!
  ): Boolean!

  # Resends the unlock account email to a user
  resendUnlockAccountEmail(
    # The email address of the user
    email: String!
  ): Boolean!

  # Resets a user's password
  resetPassword(
    # The new password
    password: String!

    # The reset token from the password reset email
    token: String!
  ): SessionToken

  # Updates the current user account
  saveAccount(
    # Updated fields of the user
    data: UserChangeset!

    # Password of the current user to confirm the update
    password: String!
  ): User

  # Updates an organization
  saveOrganization(
    # Updated fields of the organization
    data: OrganizationChangeset!

    # ID of the organization to update
    id: ID!
  ): Organization

  # Updates a repository
  saveRepository(
    # Updated fields of the repository
    data: RepositoryChangeset!

    # ID of the repository to update
    id: ID!
  ): Repository

  # Sets the default branch
  setDefaultBranch(
    # The name of the branch to make it the default
    name: String!

    # The repository to create the tag in
    repositoryId: ID!
  ): Branch

  # Signs in a user
  signIn(
    # The user's password
    password: String!

    # The user's name
    username: String!
  ): SessionToken

  # Signs up a user
  signUp(
    # A reCAPTCHA token
    captcha: String!

    # The new user's data
    user: NewUser!
  ): SessionToken

  # Unlocks a locked user account
  unlockAccount(
    # The unlock account token from the unlock account email
    token: String!
  ): SessionToken

  # Processes a git push. Can only be called by the GitShell.
  updateRefs(
    # The ID of the public key that was used to push
    keyId: Int!

    # The repository to create the branch in
    repositoryId: ID!

    # The refs that have been updated
    updatedRefs: [UpdatedRef!]!
  ): Boolean!
}

# A NativeDocument is a container for exactly one OMS
type NativeDocument implements Document & LocIdBase {
  # All DocumentLinks that this Document is part of
  documentLinks(
    # Maximum number of entries to list
    limit: Int = 20

    # Specifies which end of the link the current document is. Possible values: 'source', 'target'
    origin: LinkOrigin = any

    # Skip the first n entries
    skip: Int = 0
  ): [DocumentLink!]!

  # The FileVersion to which this object belongs
  fileVersion: FileVersion!

  # The documents which import this Document
  importedBy(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [Document!]!

  # The documents which are imported by this Document
  imports(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [Document!]!

  # The Loc/Id of the document
  locId: ID!

  # The OMS in this NativeDocument
  oms: OMS!
}

# Data for committing
input NewCommit {
  # The name of a branch to commit to
  branch: ID!

  # The changes to commit to the repository
  files: [FileChangeset!]!

  # The last known id (sha hash) of the HEAD of the branch. This is used to check
  # whether or not the branch has changed in the meantime.
  lastKnownHeadId: ID

  # A brief description of the changes in this commit
  message: String!
}

# Contains all fields that are possible to set when creating a new
# organization
input NewOrganization {
  # A short description of the organization
  description: String

  # The name of the organization
  displayName: String

  # ID of the new organization
  id: ID!
}

# Data of a new repository
input NewRepository {
  # The content type of the repository
  contentType: RepositoryContentType!

  # The description of the repository
  description: String

  # Name of the repository
  name: ID!

  # The ID of the owner
  owner: String!

  # The visibility of the repository
  visibility: RepositoryVisibility!
}

# Data for a new url mapping
input NewUrlMapping {
  # The search substring of the URL
  source: String!

  # The replacement string of the URL
  target: String!
}

# Data of a a new user that is about to sign up
input NewUser {
  # The name of the user
  displayName: String

  # The email address of the user
  email: String!

  # The password of the user
  password: String!

  # Name/id of the user
  username: ID!
}

# An Ontology, Model or Specification (OMS)
type OMS implements LocIdBase {
  # Information about the (to be) performed action
  action: Action!

  # The conservativity status of this OMS
  conservativityStatus: ConservativityStatus!

  # The attempts to check this OMS's consistency
  consistencyCheckAttempts(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [ConsistencyCheckAttempt!]!

  # The consistency status of this ConsistencyCheckAttempt
  consistencyStatus: ConsistencyStatus!

  # The description of this OMS
  description: String

  # The human-friendly name of this OMS
  displayName: String!

  # The Document containing this OMS
  document: Document!

  # The FileVersion to which this object belongs
  fileVersion: FileVersion!

  # The free normal form of this OMS
  freeNormalForm: OMS

  # The signature morphism leading to the free normal form
  freeNormalFormSignatureMorphism: SignatureMorphism

  # Flag indicating whether this OMS uses freeness
  labelHasFree: Boolean!

  # Flag indicating whether this OMS uses hiding
  labelHasHiding: Boolean!

  # The Language of this OMS
  language: Language!

  # The Loc/Id of the document
  locId: ID!

  # The Logic of this OMS
  logic: Logic!

  # Mappings of which this OMS is the the source or the target
  mappings(
    # Maximum number of entries to list
    limit: Int = 20

    # Specifies which end of the link the current OMS is
    origin: LinkOrigin = any

    # Skip the first n entries
    skip: Int = 0
  ): [Mapping]!

  # The technical name of this OMS
  name: String!

  # The technical name extension of this OMS
  nameExtension: String!

  # The index of this OMS by the name+extension
  nameExtensionIndex: Int!

  # The Range of the name of this OMS
  nameFileRange: FileRange

  # The normal form of this OMS
  normalForm: OMS

  # The signature morphism leading to the normal form
  normalFormSignatureMorphism: SignatureMorphism

  # The origin of this OMS
  origin: OMSOrigin!

  # All sentneces in this OMS
  sentences(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [Sentence!]!

  # The Serialization of this OMS
  serialization: Serialization

  # The Signature of this OMS
  signature: Signature!
}

# Specifies the origin of the OMS
enum OMSOrigin {
  # cofree OMS
  cofree

  # alignment
  dg_alignment

  # basic OMS
  dg_basic

  # basic OMS
  dg_basic_spec

  # closed OMS (CASL syntax)
  dg_closed

  # data part of an OMS
  dg_data

  # empty OMS
  dg_empty

  # extension OMS
  dg_extension

  # OMS module extraction
  dg_extract

  # fitting argument (CASL syntax)
  dg_fit_spec

  # fitting view (CASL syntax)
  dg_fit_view

  # flattening of an OMS
  dg_flattening

  # formal parameter OMS
  dg_formal_params

  # import OMS (CASL syntax)
  dg_imports

  # instantiation of a parameterized OMS (CASL syntax)
  dg_inst

  # computation of strongly connected component
  dg_integrated_scc

  # OMS intersection
  dg_intersect

  # local OMS (CASL syntax)
  dg_local

  # logic coercion OMS
  dg_logic_coercion

  # logic qualification
  dg_logic_qual

  # computation of normal form or colimit
  dg_normal_form

  # proof in the development graph calculus
  dg_proof

  # OMS hiding
  dg_restriction

  # OMS translation after hiding
  dg_reveal_translation

  # used for testing purposes
  dg_test

  # OMS translation
  dg_translation

  # OMS union
  dg_union

  # free OMS
  free

  # minimization OMS
  minimize

  # free OMS generated by Maude
  np_free
}

# An open (unproved) conjecture
type OpenConjecture implements Conjecture & LocIdBase & Sentence {
  # Information about the (to be) performed action
  action: Action!

  # The FileRange of this Sentence's definition
  fileRange: FileRange

  # The FileVersion to which this object belongs
  fileVersion: FileVersion!

  # The Loc/Id of the document
  locId: ID!

  # The name of the Sentence
  name: String!

  # The OMS to which this Sentence belongs
  oms: OMS!

  # The attempts to prove this Conjecture
  proofAttempts(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [ProofAttempt!]!

  # The proof status of this Conjecture
  proofStatus: ProofStatus!

  # The symbols used in this sentence
  symbols(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [Symbol!]!

  # The definitional text of this Sentence
  text: String!
}

# Data of an organization
type Organization implements OrganizationalUnit {
  # Description of the organization
  description: String

  # Display name of the organizational unit
  displayName: String

  # ID of the organizational unit
  id: ID!

  # List of the organization's memberships
  memberships(
    # Maximum number of memberships to list
    limit: Int = 20

    # Filter the users by the membership role
    role: OrganizationRole

    # Skip the first n memberships
    skip: Int = 0
  ): [OrganizationMembership!]!

  # The current_user's permissions for this organization
  permissions: OrganizationPermissions

  # List of repositories owned by this organizational unit
  repositories(
    # Maximum number of repositories to list
    limit: Int = 20

    # Skip the first n repositories
    skip: Int = 0
  ): [Repository!]!
}

# Contains all fields of an organization that can be changed
input OrganizationChangeset {
  # A short description of the organization
  description: String

  # The name of the organization
  displayName: String
}

# The membership of a user in an organization
type OrganizationMembership {
  # The member
  member: User!

  # The organization
  organization: Organization!

  # The member's role in the organization
  role: OrganizationRole!
}

# Holds permission information for an organization
type OrganizationPermissions {
  # The user's role in the organization
  role: OrganizationRole!
}

# A user's role in an organization
enum OrganizationRole {
  admin
  read
  write
}

# Common fields of organizational units
interface OrganizationalUnit {
  # Display name of the organizational unit
  displayName: String

  # ID of the organizational unit
  id: ID!

  # List of repositories owned by this organizational unit
  repositories(
    # Maximum number of repositories to list
    limit: Int = 20

    # Skip the first n repositories
    skip: Int = 0
  ): [Repository!]!
}

# A selection of premises for reasoning
interface PremiseSelection {
  # The ID of the PremiseSelection
  id: Int!

  # The used ReasonerConfiguration
  reasonerConfiguration: ReasonerConfiguration!

  # The selected premises
  selectedPremises(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [Sentence!]!
}

# An attempt to prove a conjecture
type ProofAttempt implements ReasoningAttempt {
  # Information about the (to be) performed action
  action: Action!

  # The conjecture of interest
  conjecture: Conjecture!

  # Axioms that have been generated during reasoning
  generatedAxioms: [GeneratedAxiom!]!

  # The ID of this ReasoningAttempt
  id: Int!

  # The number of this ReasoningAttempt
  number: Int!

  # The proof status of this ProofAttempt
  proofStatus: ProofStatus!

  # The used ReasonerConfiguration
  reasonerConfiguration: ReasonerConfiguration!

  # The output of the Reasoner
  reasonerOutput: ReasonerOutput

  # The time it took to run the reasoner
  timeTaken: Int

  # The used Reasoner
  usedReasoner: Reasoner!

  # The sentences used by this ProofAttempt
  usedSentences: [Sentence!]!
}

# Specifies the proof status of a Conjecture
enum ProofStatus {
  # Contradictory: There are proof attempts that found a proof as well as some
  # that found a counter example. This indicates a malfunction of the reasoning system.
  CONTR

  # CounterSatisfiable: A counter example was found.
  CSA

  # CounterSatisfiable on a subset of axioms: A counter example was found but only
  # a subset of the axioms was used. There is no conclusive result.
  CSAS

  # Error: A proof attempt has failed.
  ERR

  # Open: No proof attempt has been finished.
  OPN

  # ResourceOut: The reasoner ran out of time/memory.
  RSO

  # Theorem: A proof was found.
  THM

  # Unknown: There is no solution.
  UNK
}

# A SSH public key
type PublicKey {
  # MD5 fingerprint of the key
  fingerprint: String!

  # The actual SSH public key
  key: String!

  # Name of the key
  name: String!
}

# Base query type
type Query {
  # A GeneratedAxiom
  generatedAxiom(
    # The id of the GeneratedAxiom
    id: Int!
  ): GeneratedAxiom

  # Tells whether or not a public key has git access
  gitAuthorization(
    # The action to authorize
    action: GitAction!

    # The ID of the public key for authorization
    keyId: Int!

    # The ID of the repository for authorization
    repositoryId: ID!
  ): Boolean

  # A Language for the given ID
  language(
    # The ID of the Langauge
    id: ID!
  ): Language

  # A LanguageMapping for the given ID
  languageMapping(
    # The ID of the LangaugeMapping
    id: Int!
  ): LanguageMapping

  # A Logic for the given ID
  logic(
    # The ID of the Langauge
    id: ID!
  ): Logic

  # A LogicMapping for the given ID
  logicMapping(
    # The ID of the LogicMapping
    id: ID!
  ): LogicMapping

  # The currently signed in user
  me: User

  # The organizational unit for the given ID
  organizationalUnit(
    # ID of the organizational unit
    id: ID!
  ): OrganizationalUnit

  # A PremiseSelection
  premiseSelection(
    # The id of the PremiseSelection
    id: Int!
  ): PremiseSelection

  # A Reasoner
  reasoner(
    # The id of the Reasoner
    id: ID!
  ): Reasoner

  # A ReasonerConfiguration
  reasonerConfiguration(
    # The id of the ReasonerConfiguration
    id: Int!
  ): ReasonerConfiguration

  # A ReasoningAttempt
  reasoningAttempt(
    # The id of the ReasoningAttempt
    id: Int!
  ): ReasoningAttempt

  # The repository for the given ID
  repository(
    # ID of the repository
    id: ID!
  ): Repository

  # Search Ontohub
  search(
    # The query string
    query: String!
  ): SearchResult!

  # A Serialization for the given ID
  serialization(
    # The ID of the Serialization
    id: ID!
  ): Serialization

  # A Signature
  signature(
    # The id of the Signature
    id: Int!
  ): Signature

  # A SignatureMorphism
  signatureMorphism(
    # The id of the SignatureMorphism
    id: Int!
  ): SignatureMorphism

  # The version of the running backend
  version: Version!
}

# A search result entry
type RankedGlobalSearchEntry {
  # The actual result entry
  entry: GlobalSearchEntry!

  # The ranking of the result entry. The higher the value, the better it
  # matches the search query
  ranking: Float!
}

# A Reasoning system (prover or consistency checker)
type Reasoner {
  # The human-friendly name of this reasoner
  displayName: String!

  # The ID of the reasoner
  id: ID!
}

# A configuration of a Reasoner for a ReasoningAttempt
type ReasonerConfiguration {
  # The configured Reasoner
  configuredReasoner: Reasoner

  # The ID of the ReasonerConfiguration
  id: Int!

  # The PremiseSelections that use this configuration
  premiseSelections: [PremiseSelection!]!

  # The reasoningAttempts that use this configuration
  reasoningAttempts: [ReasoningAttempt!]!

  # How much time a reasoner can work on a reasoning task
  timeLimit: Int
}

# The output of a Reasoner
type ReasonerOutput {
  # The Reasoner that produced this output
  reasoner: Reasoner!

  # The ReasoningAttempt in which this axiom has been generated
  reasoningAttempt: ReasoningAttempt!

  # The actual output
  text: String!
}

# An attempt to prove a conjecture or check consistency of an OMS
interface ReasoningAttempt {
  # Information about the (to be) performed action
  action: Action!

  # Axioms that have been generated during reasoning
  generatedAxioms: [GeneratedAxiom!]!

  # The ID of this ReasoningAttempt
  id: Int!

  # The number of this ReasoningAttempt
  number: Int!

  # The used ReasonerConfiguration
  reasonerConfiguration: ReasonerConfiguration!

  # The output of the Reasoner
  reasonerOutput: ReasonerOutput

  # The time it took to run the reasoner
  timeTaken: Int

  # The used Reasoner
  usedReasoner: Reasoner!
}

# A git reference
interface Reference {
  # The name of the reference
  name: String!

  # The referenced commit
  target: Commit!
}

# Data of a repository
type Repository implements BaseRepository {
  # Details of a branch
  branch(
    # The name of the branch
    name: String!
  ): Branch

  # Branches of the repository
  branches: [String!]!

  # Find a commit by revision
  commit(
    # The revision to query for (default: What is retruned in the defaultBranch field)
    revision: ID
  ): Commit

  # Type of the repository
  contentType: RepositoryContentType!

  # Default branch of the repository
  defaultBranch: String

  # Description of the repository
  description: String

  # The changes between two commits
  diff(
    # The base revision for the diff
    from: ID!

    # An optional list of paths to restrict the diff to
    paths: [String!]

    # The target revision for the diff
    to: ID!
  ): [Diff!]!

  # ID of the repository
  id: ID!

  # The history (git log) of the repository starting with the most recent changes
  log(
    # Only show commits from after this date/time
    after: Time

    # Only show commits from before this date/time
    before: Time

    # Maximum number of commits to list
    limit: Int = 20

    # A path to a file or directory to see the history of
    path: String = "/"

    # The newest revision to show in the history
    revision: String

    # Skip the first n commits
    skip: Int = 0

    # Whether or not to skip merge commits in the history
    skipMerges: Boolean = false
  ): [Commit!]!

  # List of the repository's memberships
  memberships(
    # Maximum number of memberships to list
    limit: Int = 20

    # Filter the users by the membership role
    role: RepositoryRole

    # Skip the first n memberships
    skip: Int = 0
  ): [RepositoryMembership!]!

  # Name of the repository
  name: String!

  # Owner of the repository
  owner: OrganizationalUnit!

  # The current_user's permissions for this repository
  permissions: RepositoryPermissions

  # The repository's readme file
  readme(
    # The repository's revision
    revision: ID
  ): File

  # Details of a tag
  tag(
    # The name of the tag
    name: String!
  ): Tag

  # Tags of the repository
  tags: [String!]!

  # List of all URL Mappings of this repository
  urlMappings: [UrlMapping!]!

  # Visibility of the repository
  visibility: RepositoryVisibility!
}

# Contains all fields of a repository that can be changed
input RepositoryChangeset {
  # The content type of the repository
  contentType: RepositoryContentType

  # A short description of the repository
  description: String

  # The visibility of the repository
  visibility: RepositoryVisibility
}

# Possible types of repositories
enum RepositoryContentType {
  mathematical
  model
  ontology
  specification
}

# The membership of a user in a repository
type RepositoryMembership {
  # The member
  member: User!

  # The repository
  repository: Repository!

  # The member's role in the repository
  role: RepositoryRole!
}

# Holds permission information for an repository
type RepositoryPermissions {
  # The user's role in the repository
  role: RepositoryRole!
}

# Possible values for repository remote types
enum RepositoryRemoteType {
  # A copy of a repository
  fork

  # A read-only copy of a repository that is synchronized periodically
  mirror
}

# Possible values for repository roles
enum RepositoryRole {
  admin
  read
  write
}

# Possible values for repository visibilities
enum RepositoryVisibility {
  private
  public
}

# Data of a repository without git
type RepositoryWithoutGit implements BaseRepository {
  # Type of the repository
  contentType: RepositoryContentType!

  # Description of the repository
  description: String

  # ID of the repository
  id: ID!

  # List of the repository's memberships
  memberships(
    # Maximum number of memberships to list
    limit: Int = 20

    # Filter the users by the membership role
    role: RepositoryRole

    # Skip the first n memberships
    skip: Int = 0
  ): [RepositoryMembership!]!

  # Name of the repository
  name: String!

  # Owner of the repository
  owner: OrganizationalUnit!

  # The current_user's permissions for this repository
  permissions: RepositoryPermissions

  # List of all URL Mappings of this repository
  urlMappings: [UrlMapping!]!

  # Visibility of the repository
  visibility: RepositoryVisibility!
}

# Result returned from a search query
type SearchResult {
  # Search within the global scope
  global(
    # Limit search to certain categories
    categories: [GlobalSearchCategory]
  ): GlobalSearchScope!
}

# A logical sentence
interface Sentence {
  # The FileRange of this Sentence's definition
  fileRange: FileRange

  # The FileVersion to which this object belongs
  fileVersion: FileVersion!

  # The Loc/Id of the document
  locId: ID!

  # The name of the Sentence
  name: String!

  # The OMS to which this Sentence belongs
  oms: OMS!

  # The symbols used in this sentence
  symbols(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [Symbol!]!

  # The definitional text of this Sentence
  text: String!
}

# A serialization of a language
type Serialization {
  # The ID of this serialization
  id: ID!

  # The language to which this serialization belongs
  language: Language!

  # The name of this serialization
  name: String!
}

# Data of a signed in user
type SessionToken {
  # The session token
  jwt: String!

  # The current user
  me: User!
}

# A signautre of an OMS is a container for the OMS's symbols
type Signature {
  # The signature's symbols in JSON
  asJson: String!

  # The ID of this signature
  id: Int!

  # OMS that have this signature
  oms: [OMS!]!

  # The SignatureMorphisms of which this Signature is the target
  signatureMorphisms(
    # Maximum number of entries to list
    limit: Int = 20

    # Specifies which end of the link the current Signature is
    origin: LinkOrigin = any

    # Skip the first n entries
    skip: Int = 0
  ): [SignatureMorphism!]!

  # The Symbols of this Signature
  symbols(
    # Maximum number of entries to list
    limit: Int = 20

    # Whether or not only (non-)imported Symbols should be retrieved
    origin: SymbolOrigin = either

    # Skip the first n entries
    skip: Int = 0
  ): [Symbol!]!
}

# A morphism between two Signatures
type SignatureMorphism {
  # The SignatureMorphism's mappings in JSON
  asJson: String!

  # The ID of the SignatureMorphism
  id: Int!

  # The LogicMapping which this SignatureMorphism uses
  logicMapping: LogicMapping!

  # The Mappings that use this SignatureMorphism
  mappings: [Mapping!]!

  # The source Signature
  source: Signature!

  # The SymbolMappings of this SignatureMorphism
  symbolMappings: [SymbolMapping!]!

  # The target Signature
  target: Signature!
}

# The SInE premise selection heuristic
type SinePremiseSelection implements PremiseSelection {
  # The maximum number of iterations to be done by the SInE heuristic. The higher,
  # the more premises are selected. A null value indicates that this feature is disabled.
  depthLimit: Int!

  # The ID of the PremiseSelection
  id: Int!

  # The number of premises to be selected at most. A null value indicates that this feature is disabled.
  premiseNumberLimit: Int

  # The used ReasonerConfiguration
  reasonerConfiguration: ReasonerConfiguration!

  # The selected premises
  selectedPremises(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [Sentence!]!

  # Shows in how many Sentences of the OMS a Symbol occurs
  sineSymbolCommonnesses(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [SineSymbolCommonness!]!

  # Shows the tolerance needed for a Symbol to trigger (select) a premise
  sineSymbolPremiseTriggers(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [SineSymbolPremiseTrigger!]!

  # A higher tolerance value causes more premises to be selected. Minimum value: 1.0.
  tolerance: Float!
}

# Shows in how many Sentences of the OMS a Symbol occurs
type SineSymbolCommonness {
  # The commonness of the symbol (number of sentences in which it occurs)
  commonness: Int!

  # The SinePremiseSelection
  sinePremiseSelection: SinePremiseSelection!

  # The Symbol
  symbol: Symbol!
}

# Shows the tolerance needed for a Symbol to trigger (select) a premise
type SineSymbolPremiseTrigger {
  # The tolerance needed for a Symbol to trigger (select) a premise
  minTolerance: Float!

  # The premise
  premise: Sentence!

  # The SinePremiseSelection
  sinePremiseSelection: SinePremiseSelection!

  # The Symbol
  symbol: Symbol!
}

# A (non-logical) symbol
type Symbol implements LocIdBase {
  # The FileRange of this Symbol's definition
  fileRange: FileRange

  # The FileVersion to which this object belongs
  fileVersion: FileVersion!

  # The fully qualified name of the Symbol
  fullName: String!

  # The kind of the Symbol
  kind: String!

  # The Loc/Id of the document
  locId: ID!

  # The name of the Symbol
  name: String!

  # The OMS to which this Symbol belongs to
  oms: OMS!

  # The Sentences in which this Symbol occurs
  sentences(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [Sentence!]!

  # The Signatures in which this Symbol occurs
  signatures(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [Signature!]!
}

# A mapping between two symbols along a SignatureMorphism
type SymbolMapping {
  # The SignatureMorphism to which this SymbolMapping belongs
  signatureMorphism: SignatureMorphism!

  # The source symbol
  source: Symbol!

  # The target symbol
  target: Symbol!
}

# Specifies which end of the link the current Symbol is
enum SymbolOrigin {
  # The current Symbol is either imported or or not
  either

  # The current Symbol is imported
  imported

  # The current Symbol is not imported
  non_imported
}

# A git tag
type Tag implements Reference {
  # An annotation of the tag
  annotation: String

  # The name of the reference
  name: String!

  # The referenced commit
  target: Commit!
}

# A theorem (proved conjecture)
type Theorem implements Conjecture & LocIdBase & Sentence {
  # Information about the (to be) performed action
  action: Action!

  # The FileRange of this Sentence's definition
  fileRange: FileRange

  # The FileVersion to which this object belongs
  fileVersion: FileVersion!

  # The Loc/Id of the document
  locId: ID!

  # The name of the Sentence
  name: String!

  # The OMS to which this Sentence belongs
  oms: OMS!

  # The attempts to prove this Conjecture
  proofAttempts(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [ProofAttempt!]!

  # The proof status of this Conjecture
  proofStatus: ProofStatus!

  # The symbols used in this sentence
  symbols(
    # Maximum number of entries to list
    limit: Int = 20

    # Skip the first n entries
    skip: Int = 0
  ): [Symbol!]!

  # The definitional text of this Sentence
  text: String!
}

# Represents the time
scalar Time

# Updated Git Ref
input UpdatedRef {
  # The (sha hash) of the ref after the update
  after: ID

  # The (sha hash) of the ref before the update
  before: ID

  # The name of the ref that was updated
  ref: ID!
}

# Search and replace pattern for URLs inside documents
type UrlMapping {
  # ID of the UrlMapping
  id: ID!

  # Defines the sequence in which the mappings are applied
  number: Int!

  # The search substring of the URL
  source: String!

  # The replacement string of the URL
  target: String!
}

# Data of a user
type User implements OrganizationalUnit {
  # Display name of the organizational unit
  displayName: String

  # Email address of the user
  email: String

  # MD5 hash of the user's email address
  emailHash: String!

  # ID of the organizational unit
  id: ID!

  # List of the user's organization memberships
  organizationMemberships(
    # Maximum number of memberships to list
    limit: Int = 20

    # Filter the organizations by the membership role
    role: OrganizationRole

    # Skip the first n memberships
    skip: Int = 0
  ): [OrganizationMembership!]!

  # List of a user's SSH public keys
  publicKeys: [PublicKey!]

  # List of repositories owned by this organizational unit
  repositories(
    # Maximum number of repositories to list
    limit: Int = 20

    # Skip the first n repositories
    skip: Int = 0
  ): [Repository!]!

  # List of the user's repository memberships
  repositoryMemberships(
    # Maximum number of memberships to list
    limit: Int = 20

    # Filter the repositories by the membership role
    role: RepositoryRole

    # Skip the first n memberships
    skip: Int = 0
  ): [RepositoryMembership!]!

  # Email address of the user that still needs to be confirmed
  unconfirmedEmail: String
}

# Contains all fields of a user account that can be changed
input UserChangeset {
  # The name of the user
  displayName: String

  # The email address of the user
  email: String

  # The password of the user
  password: String
}

# Version of the running backend
type Version {
  # Short git hash of the deployed version
  commit: String!

  # Amount of commits since the last version bump
  commitsSinceTag: Int!

  # Full version as generated by `git describe --long --tags`
  full: String!

  # Last published version
  tag: String!
}

# A warning
type Warn implements Diagnosis {
  # The FileRange that this message is about
  fileRange: FileRange

  # The FileVersion which this message is about
  fileVersion: FileVersion!

  # The number of this message
  number: Int!

  # The actual message
  text: String!
}
